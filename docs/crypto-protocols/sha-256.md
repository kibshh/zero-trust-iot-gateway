# SHA-256

Secure Hash Algorithm producing a 256-bit digest.

## What Problem Does It Solve?

You have a file - maybe firmware, a document, or a message. How do you create a unique "fingerprint" of that file? Something that:
- Is always the same length (regardless of input size)
- Changes completely if even one bit of the input changes
- Can't be reversed to recover the original

SHA-256 solves this. Feed it any data (1 byte or 1 gigabyte), and it produces a fixed 256-bit (32-byte) output called a digest or hash. This digest uniquely identifies the input - like a fingerprint for data.

## The Core Properties

| Property | Meaning |
|----------|---------|
| **Deterministic** | Same input always produces same output |
| **Fixed output** | Always 256 bits, regardless of input size |
| **Avalanche effect** | Change 1 bit → ~50% of output bits change |
| **Pre-image resistant** | Given hash h, can't find m where SHA-256(m) = h |
| **Collision resistant** | Can't find two inputs m₁ ≠ m₂ with same hash |

## How It Works

SHA-256 processes input in 512-bit (64-byte) blocks. Each block goes through 64 rounds of mixing operations.

### Step 1: Padding

The message is padded to a multiple of 512 bits:

```
Original message:  M
Padded message:    M || 1 || 000...0 || length

where:
  || means concatenation
  1 is a single bit
  000...0 fills to 448 bits mod 512
  length is original message length as 64-bit integer
```

Example: "abc" (24 bits) becomes:
```
01100001 01100010 01100011 1 000...000 00000000 00011000
   'a'      'b'      'c'   ↑   padding      24 in binary
                         delimiter
```

### Step 2: Initialize Hash Values

Eight 32-bit words, derived from the square roots of the first 8 primes:

```
H₀ = 0x6a09e667    (from √2)
H₁ = 0xbb67ae85    (from √3)
H₂ = 0x3c6ef372    (from √5)
H₃ = 0xa54ff53a    (from √7)
H₄ = 0x510e527f    (from √11)
H₅ = 0x9b05688c    (from √13)
H₆ = 0x1f83d9ab    (from √17)
H₇ = 0x5be0cd19    (from √19)
```

### Step 3: Process Each Block

For each 512-bit block:

**Message Schedule (W₀ to W₆₃):**
```
W₀ to W₁₅ = the 16 words from the block

W₁₆ to W₆₃:
  Wᵢ = σ₁(Wᵢ₋₂) + Wᵢ₋₇ + σ₀(Wᵢ₋₁₅) + Wᵢ₋₁₆

where:
  σ₀(x) = ROTR⁷(x) ⊕ ROTR¹⁸(x) ⊕ SHR³(x)
  σ₁(x) = ROTR¹⁷(x) ⊕ ROTR¹⁹(x) ⊕ SHR¹⁰(x)
  ROTR = rotate right
  SHR = shift right
  ⊕ = XOR
```

**Compression (64 rounds):**
```
Initialize working variables:
  a, b, c, d, e, f, g, h = H₀, H₁, H₂, H₃, H₄, H₅, H₆, H₇

For i = 0 to 63:
  Σ₀ = ROTR²(a) ⊕ ROTR¹³(a) ⊕ ROTR²²(a)
  Σ₁ = ROTR⁶(e) ⊕ ROTR¹¹(e) ⊕ ROTR²⁵(e)
  Ch = (e ∧ f) ⊕ (¬e ∧ g)          [Choose: if e then f else g]
  Maj = (a ∧ b) ⊕ (a ∧ c) ⊕ (b ∧ c) [Majority of a,b,c]
  
  T₁ = h + Σ₁ + Ch + Kᵢ + Wᵢ
  T₂ = Σ₀ + Maj
  
  h = g
  g = f
  f = e
  e = d + T₁
  d = c
  c = b
  b = a
  a = T₁ + T₂

Add to hash:
  H₀ += a, H₁ += b, ..., H₇ += h
```

The constants K₀ to K₆₃ come from the cube roots of the first 64 primes.

### Step 4: Final Hash

Concatenate the eight 32-bit values:

```
Hash = H₀ || H₁ || H₂ || H₃ || H₄ || H₅ || H₆ || H₇
     = 256 bits = 32 bytes
```

## The Avalanche Effect

Changing one bit causes massive output change:

```
SHA-256("hello")  = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
SHA-256("hallo")  = d3751d33f9cd5049c4af2b462735457e4d3baf130bcbb87f389e349fbaeb20b9
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    Completely different (looks random)
```

Even though inputs differ by 1 bit ('e' vs 'a'), the outputs share no obvious pattern.

## Why These Operations?

| Operation | Purpose |
|-----------|---------|
| **ROTR (rotate)** | Spreads bit influence across the word |
| **XOR** | Reversible mixing without losing information |
| **Addition mod 2³²** | Non-linear mixing (harder to analyze) |
| **Ch (choose)** | Conditional selection based on e |
| **Maj (majority)** | Voting function smooths bit distribution |

Each round mixes the state thoroughly. After 64 rounds, every output bit depends on every input bit in a complex, non-invertible way.

## Streaming/Chunked Hashing

SHA-256's block structure allows incremental hashing:

```
┌─────────────────────────────────────────────────────────┐
│  Large file (e.g., firmware)                            │
│  ┌──────┬──────┬──────┬──────┬──────┬─────┐           │
│  │Block1│Block2│Block3│Block4│Block5│ ... │           │
│  └──────┴──────┴──────┴──────┴──────┴─────┘           │
│     │      │      │      │      │                      │
│     ▼      ▼      ▼      ▼      ▼                      │
│   [H₀-H₇]→[H₀-H₇]→[H₀-H₇]→[H₀-H₇]→[H₀-H₇]→ ... →Hash │
│                                                         │
│  Memory needed: only 64 bytes state + 64 bytes block   │
│  Never need entire file in memory                       │
└─────────────────────────────────────────────────────────┘
```

This is why we can hash gigabyte firmware on memory-constrained devices.

## Why 256 Bits?

Security is approximately 2^(n/2) for collision resistance:
- SHA-256: 2¹²⁸ operations to find collision (infeasible)
- SHA-1 (160-bit): 2⁸⁰ operations (broken in 2017)

256 bits also matches well with ECDSA P-256 - the hash output feeds directly into the signature algorithm.

## Common Pitfalls

| Mistake | Problem |
|---------|---------|
| **Using for passwords** | Too fast! Use bcrypt/Argon2 instead |
| **Assuming uniqueness** | Collisions exist (theoretically), just hard to find |
| **Length extension** | SHA-256(secret \|\| data) is vulnerable; use HMAC |

## The One Guarantee

Given a hash value, finding any input that produces it requires approximately 2²⁵⁶ attempts - more than atoms in the observable universe. This is why we trust SHA-256 to fingerprint firmware: if the hash matches, the firmware is identical to the original.

